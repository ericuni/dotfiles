snippet snippet_cmd "cmd template" b
#include <gflags/gflags.h>
#include <spdlog/spdlog.h>
#include <stdio.h>

#include "base/fmt.h"  // IWYU pragma: keep

using namespace spdlog;

int main(int argc, char* argv[]) {
  google::ParseCommandLineFlags(&argc, &argv, true);

  return 0;
}
endsnippet

snippet snippet_ut "unit test" b
#include <gmock/gmock-matchers.h>
#include <gperftools/heap-checker.h>
#include <gtest/gtest.h>
#include <spdlog/spdlog.h>

#include "base/fmt.h"  // IWYU pragma: keep

using namespace spdlog;
endsnippet

snippet snippet_leetcode "leetcode solution" b
#include <gmock/gmock-matchers.h>
#include <gperftools/heap-checker.h>
#include <gtest/gtest.h>
#include <spdlog/spdlog.h>

#include "base/fmt.h"  // IWYU pragma: keep

using namespace spdlog;
/*

*/

class Solution {
 public:
  virtual ~Solution() {}
};

class Solution$2 : public Solution {
 public:
};

TEST($1, ex) {
  struct TestData {
  } tds[]{
  };

  std::vector<std::unique_ptr<Solution>> sos;
  sos.push_back(std::make_unique<Solution$2>());

  for (auto&& so : sos) {
    info("new solution");
    for (auto&& td : tds) {
      info("input={}", td.xxx);
    }
  }
}
endsnippet

