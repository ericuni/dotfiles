snippet snippet_cmd "cmd template" b
#include <gflags/gflags.h>
#include <glog/logging.h>
#include <stdio.h>

#include "thirdparty/fmt/fmt.h"

int main(int argc, char* argv[]) {
  FLAGS_alsologtostderr = true;
  FLAGS_colorlogtostderr = true;
  google::InitGoogleLogging(argv[0]);
  google::ParseCommandLineFlags(&argc, &argv, true);

  return 0;
}
endsnippet

snippet snippet_ut "unit test" b
#include <glog/logging.h>
#include <gmock/gmock-matchers.h>
#include <gperftools/heap-checker.h>
#include <gtest/gtest.h>

#include "thirdparty/fmt/fmt.h"

endsnippet

snippet snippet_leetcode "leetcode solution" b
#include <glog/logging.h>
#include <gmock/gmock-matchers.h>
#include <gperftools/heap-checker.h>
#include <gtest/gtest.h>

#include "thirdparty/fmt/fmt.h"

/*

*/

class Solution {
 public:
  virtual ~Solution() {}
};

class Solution$2 : public Solution {
 public:
};

TEST($1, ex) {
  struct TestData {
  } tds[]{
  };

  std::vector<std::unique_ptr<Solution>> sos;
  sos.push_back(std::make_unique<Solution$2>());

  for (auto&& so : sos) {
    for (auto&& td : tds) {
      LOG(INFO) << fmt::format("input={}", td.xxx);
    }
  }
}
endsnippet

