snippet entry_repo "comments_build_tools orm interface" b
/*
import (
	"gorm.io/gorm"
)
*/
type ${1:Table}Repo interface {
	// sql(value="select * from ${2:table} where id = #id", mode = "named_placeholder")
	FindByID(ctx context.Context, id int64) (*ddl.${1:Table}, error)
}

var (
	${2:table}R    ${1:Table}Repo
	${2:table}W    ${1:Table}Repo
	${2:table}Once sync.Once
)

func Init${1:Table}(testdb *gorm.DB) {
	${2:table}Once.Do(func() {
		if testdb != nil {
			${2:table}R = New${1:Table}Repo(testdb)
			${2:table}W = ${2:table}R
			return
		}

		${2:table}R = New${1:Table}Repo(db.GetMysql().ForReadV2())
		${2:table}W = New${1:Table}Repo(db.GetMysql().ForWriteV2())
	})
}

func Get${1:Table}R() ${1:Table}Repo {
	Init${1:Table}(nil)
	return ${2:table}R
}

func Get${1:Table}W() ${1:Table}Repo {
	Init${1:Table}(nil)
	return ${2:table}W
}
endsnippet

snippet entry_hertz "hertz service" b
func ${1:method}(ctx context.Context, request *model.${1}Reuqest) (data *model.${1}Data, err error) {
	data = &model.${1}Data{
	}
	return data, nil
}

endsnippet

snippet entry_kitex "kitex service" b
func ${1:method}(ctx context.Context, req *${2:service}.${1:method}Request) (rsp *${2:service}.${1:method}Response, err error) {
	rsp = &${2:service}.${1:method}Response{
		BaseResp: base.NewBaseResp(),
	}
	defer func() {
		if err != nil {
			fault.SetBaseResp(ctx, rsp.BaseResp, err)
		}
	}()

	if err := is${1:method}RequestValid(req); err != nil {
		return rsp, errors.Trace(fault.New(err_code.PopErrInvalidParam, err.Error()))
	}

	return
}

func is${1:method}RequestValid(req *${2:service}.${1:method}Request) error {
	if req == nil {
		return errors.New("req nil")
	}

	return nil
}
endsnippet

snippet handler_faas_cronjob "faas cronjob handler template" b
// ${1:Template}Handler .
type $1Handler struct {
	ctx    context.Context
	reason string
	tags   []metrics.T
	t      time.Time
}

// New$1Handler .
func New$1Handler(ctx context.Context, tags []metrics.T) *$1Handler {
	return &$1Handler{
		ctx:  ctx,
		tags: tags,
		t:    time.Now(),
	}
}

// Handle .
func (h *$1Handler) Handle() error {
	return nil
}

// GetTags .
func (h *$1Handler) GetTags() map[string]string {
	return map[string]string{trace.ReasonTag: h.reason}
}
endsnippet

snippet ut_clean "unit test template" b
type ${1:Template}Suite struct {
	suite.Suite
}

func (s *$1Suite) TestEx() {
	assert := s.Assert()
	t := s.T()
}

func Test$1(t *testing.T) {
	suite.Run(t, new($1Suite))
}
endsnippet

snippet ut "unit test template" b
type ${1:Template}Suite struct {
	suite.Suite
	ctx context.Context
}

func (s *$1Suite) SetupSuite() {
	s.ctx = context.Background()
}

func (s *$1Suite) TearDownSuite() {
}

func (s *$1Suite) SetupTest() {
}

func (s *$1Suite) TearDownTest() {
	logs.Flush()
}

func (s *$1Suite) TestEx() {
	assert := s.Assert()
	t := s.T()
}

func Test$1(t *testing.T) {
	suite.Run(t, new($1Suite))
}
endsnippet

snippet ut_http "http unit test template" b
type ${1:Template}Suite struct {
	suite.Suite
	ctx    context.Context
	router *ginex.Engine
	w      *httptest.ResponseRecorder
}

func (s *$1Suite) SetupSuite() {
	ginex.Init()
	router := ginex.Default()
	router.Get()
	s.router = router
}

func (s *$1Suite) SetupTest() {
	ctx := context.Background()
	ctx = kitutil.NewCtxWithLogID(ctx, logid.GetNginxID())
	s.ctx = ctx
	s.w = httptest.NewRecorder()
}

func (s *$1Suite) TearDownTest() {
	logs.Flush()
}

func (s *$1Suite) TestEx() {
	assert := s.Assert()
	t := s.T()

	url := fmt.Sprintf("")
	req := httptest.NewRequest(http.MethodGet, url, nil)
	s.router.ServeHTTP(s.w, req)

	rsp := s.w.Result()
	defer rsp.Body.Close()
	assert.Equal(http.StatusOK, rsp.StatusCode)

	bs, _ := ioutil.ReadAll(rsp.Body)
	t.Log(string(bs))
}

func Test$1(t *testing.T) {
	suite.Run(t, new($1Suite))
}
endsnippet

snippet glog_init "init glog" b
flag.Set("alsologtostderr", "true")
flag.Set("log_dir", "./")
flag.Parse()
endsnippet

snippet cmd "cmd" b
func init() {
	flag.Set("alsologtostderr", "true")
	flag.Set("log_dir", "./")
	flag.Parse()
}

func main() {
	defer glog.Flush()

	ctx := context.Background()
	if err := run(ctx); err != nil {
		glog.Errorf("run error %+v", err)
		return
	}
	glog.Infoln("done")
}

func run(ctx context.Context) error {
	return nil
}
endsnippet

snippet cronjob "cronjob" b
func main() {
	defer logs.Flush()

	ctx := context.Background()
	ctx = ctxvalues.SetLogID(ctx, logid.GetNginxID())

	if err := run(ctx); err != nil {
		logs.CtxError(ctx, "run error %+v", err)
		return
	}

	logs.CtxInfo(ctx, "done")
}

func run(ctx context.Context) error {
	return nil
}
endsnippet
