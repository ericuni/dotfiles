snippet handler "handler template" b
// ${1:Template}Handler .
type $1Handler struct {
	ctx  context.Context
	req  *$2.$1Request
	rsp  *$2.$1Response
	code int32
}

// New$1Handler .
func New$1Handler(ctx context.Context, req *$2.$1Request) *$1Handler {
	return &$1Handler{
		ctx: ctx,
		req: req,
		rsp: &$2.$1Response{
			BaseResp: base.NewBaseResp(),
		},
		code: err_code.PopErrInternalError,
	}
}

// Handle .
func (h *$1Handler) Handle() *$2.$1Response {
	if err := h.isValid(); err != nil {
		h.code = err_code.PopErrInvalidParam
		return h.returnAhead(errors.Trace(err))
	}

	return h.returnAhead(nil)
}

func (h *$1Handler) isValid() error {
	return nil
}

func (h *$1Handler) returnAhead(err error) *$2.$1Response {
	if err == nil {
		return h.rsp
	}

	logs.CtxError(h.ctx, "$1 error %d %+v", h.code, err)
	h.rsp.BaseResp.StatusCode = h.code
	h.rsp.BaseResp.StatusMessage = err.Error()
	return h.rsp
}
endsnippet

snippet handler_faas_cronjob "faas cronjob handler template" b
// ${1:Template}Handler .
type $1Handler struct {
	ctx    context.Context
	reason string
	tags   []metrics.T
	t      time.Time
}

// New$1Handler .
func New$1Handler(ctx context.Context, tags []metrics.T) *$1Handler {
	return &$1Handler{
		ctx:  ctx,
		tags: tags,
		t:    time.Now(),
	}
}

// Handle .
func (h *$1Handler) Handle() error {
	return nil
}

// GetTags .
func (h *$1Handler) GetTags() map[string]string {
	return map[string]string{trace.ReasonTag: h.reason}
}
endsnippet

snippet ut "unit test template" b
type ${1:Template}Suite struct {
	suite.Suite
	ctx context.Context
}

func (s *$1Suite) SetupSuite() {
	s.ctx = context.Background()
}

func (s *$1Suite) TearDownSuite() {
}

func (s *$1Suite) SetupTest() {
}

func (s *$1Suite) TearDownTest() {
	logs.Flush()
}

func (s *$1Suite) TestEx() {
	assert := s.Assert()
	t := s.T()
}

func Test$1(t *testing.T) {
	suite.Run(t, new($1Suite))
}
endsnippet

snippet ut_http "http unit test template" b
type ${1:Template}Suite struct {
	suite.Suite
	ctx    context.Context
	router *ginex.Engine
	w      *httptest.ResponseRecorder
}

func (s *$1Suite) SetupSuite() {
	ginex.Init()
	router := ginex.Default()
	router.Get()
	s.router = router
}

func (s *$1Suite) SetupTest() {
	ctx := context.Background()
	ctx = kitutil.NewCtxWithLogID(ctx, logid.GetNginxID())
	s.ctx = ctx
	s.w = httptest.NewRecorder()
}

func (s *$1Suite) TearDownTest() {
	logs.Flush()
}

func (s *$1Suite) TestEx() {
	assert := s.Assert()
	t := s.T()

	url := fmt.Sprintf("")
	req := httptest.NewRequest(http.MethodGet, url, nil)
	s.router.ServeHTTP(s.w, req)

	rsp := s.w.Result()
	defer rsp.Body.Close()
	assert.Equal(http.StatusOK, rsp.StatusCode)

	bs, _ := ioutil.ReadAll(rsp.Body)
	t.Log(string(bs))
}

func Test$1(t *testing.T) {
	suite.Run(t, new($1Suite))
}
endsnippet

snippet cmd "cmd" b
func init() {
	flag.Set("alsologtostderr", "true")
	flag.Set("log_dir", "./")
	flag.Parse()
}

func main() {
	defer glog.Flush()

	ctx := context.Background()
	if err := run(ctx); err != nil {
		glog.Errorf("run error %+v", err)
		return
	}
	glog.Infoln("done")
}

func run(ctx context.Context) error {
	return nil
}
endsnippet

