snippet cmd "cmd template" b
#include <gflags/gflags.h>
#include <glog/logging.h>
#include <stdio.h>

#include "thirdparty/fmt/fmt.h"

int main(int argc, char* argv[]) {
  FLAGS_alsologtostderr = true;
  FLAGS_colorlogtostderr = true;
  google::InitGoogleLogging(argv[0]);
  google::ParseCommandLineFlags(&argc, &argv, true);

  return 0;
}
endsnippet

snippet ut "unit test" b
#include <glog/logging.h>
#include <gperftools/heap-checker.h>
#include <gtest/gtest.h>

#include "thirdparty/fmt/fmt.h"

int main(int argc, char** argv) {
  testing::InitGoogleTest(&argc, argv);
  HeapLeakChecker heap_checker("heap checker");
  auto ret = RUN_ALL_TESTS();
  CHECK(heap_checker.NoLeaks());
  return ret;
}
endsnippet

snippet leetcode "leetcode solution" b
#include <glog/logging.h>
#include <gperftools/heap-checker.h>
#include <gtest/gtest.h>

#include "thirdparty/fmt/fmt.h"

/*

*/

class Solution {
 public:
  virtual ~Solution() {}
};

class Solution$2 : public Solution {
 public:
};

TEST($1, ex) {
  struct TestData {
  } tds[]{
  };

  std::vector<std::unique_ptr<Solution>> sos;
  sos.push_back(std::make_unique<Solution$2>());

  for (auto&& so : sos) {
    for (auto&& td : tds) {
    }
  }
}

int main(int argc, char** argv) {
  testing::InitGoogleTest(&argc, argv);
  HeapLeakChecker heap_checker("heap checker");
  auto ret = RUN_ALL_TESTS();
  CHECK(heap_checker.NoLeaks());
  return ret;
}
endsnippet

